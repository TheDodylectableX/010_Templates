//------------------------------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: TRM.bt
//   Authors: Dodylectable, MuruCoder
//   Version: 1.0
//   Purpose: Reverse engineering the Tomb Raider I-V Remastered models
//  Category: Models
// File Mask: *.TRM
//  ID Bytes: 54 52 4D 02
//   History: 
//------------------------------------------------------------------------

// Switch the type from Default to Head if you want to parse a head model!
const string Type <hidden=true> = "Default";

#include "../Common.bt"

typedef struct // Thanks MuruCoder for figuring the shaders out
{
    uint Type <name="Shader Type">;
    VEC4F Parameters <name="Shader Parameters">;
    uint OpaqueOffset <name="Opaque Offset", comment="This is the start of how many triangles that need to be rendered opaque">;
    uint OpaqueLength <name="Opaque Length", comment="This is the length of how many triangles that need to be rendered opaque, Divide by 3">;
    uint AlphaOffset <name="Alpha Offset", comment="This is the start of how many triangles that need to be rendered with alpha masking">;
    uint AlphaLength <name="Alpha Length", comment="This is the length of how many triangles that need to be rendered with alpha masking, Divide by 3">;
    uint AdditiveOffset <name="Additive Offset", comment="This is the start of how many triangles that need to be rendered additive">;
    uint AdditiveLength <name="Additive Length", comment="This is the length of how many triangles that need to be rendered additive, Divide by 3">;
} Shaders <name="Shaders">;

typedef struct
{
    char Magic[4] <name="Magic", comment="Magic of the format">;
    uint ShaderCount <name="Shader Count">;
    Shaders shaders[ShaderCount];
    uint TextureCount <name="Texture Count">;
} Header <name="Header", comment="The header of the file", read=Str("(Model Type: %s | %d Textures)", this.Magic, this.TextureCount)>;

typedef struct
{
    ushort ID <comment="Corresponds to a DDS file with the same name in TEX folder">;
} Textures <name="Textures", comment="The textures used in this model", read=Str("Texture: %d.DDS", this.ID)>;

typedef struct
{
    VEC3US Triangles;
} Triangles <name="Triangles">;

typedef struct
{
    VEC3F Matrix[4];
} Matrices <name="Matrices">;

typedef struct
{
    VEC3F Vertices;
    VEC3UB Normals <comment="Subtract 127 and normalize">;
    ubyte MaterialIndex <name="Material Index">;
    VEC3UB Indices <name="Bone Indices">;
    ubyte U <read=UByteToFloat>;
    VEC3UB Weights <name="Bone Weights">;
    ubyte V <read=UByteToFloat>;
} Vertices <name="Vertices">;

struct
{
    Header header;
    Textures textures[header.TextureCount];
    
    local ubyte zero <hidden=true>;
        zero = ReadByte();
            while (zero == 0)
{
    FSkip(1);
        zero = ReadByte();
}

if (Type == "Head")
{
    
    uint BoneCount <name="Bone Count">;

    if (BoneCount > 0) 
    {
        // A 3x4 matrix or 12-float tuple for each bone
        Matrices matrices[BoneCount] <optimize=false>;

        uint animationRelatedCountA;
        // A pair of uints for each count
        struct {
            uint animationRelatedValue[2];
        } animationRelatedValues[animationRelatedCountA];

        uint animationFrameCount;
        // Frame numbers (assuming uint based on the read_uint_tuple call)
        uint animationFrames[animationFrameCount] <comment="Frame numbers?">;

        ushort animationRelatedB;
        ushort animationRelatedC; // Unused in the logic, but still present in stream

        // This section creates a large array based on the product 
        // of unknown3 (frames) and unknown4
        if (animationFrameCount * animationRelatedB > 0)
        {
            struct {
                float matrix[12];
            } animationMatrix[animationFrameCount * animationRelatedB];
        }
    }
}

    uint FaceCount <name="Face Count", comment="Divide by 3 to get the actual count">;
    uint VertexCount <name="Vertex Count">;

    Triangles triangles[FaceCount / 3] <name="Triangles", optimize=false>;
    
    local ubyte zero_2 <hidden=true>;
        zero_2 = ReadByte();
            while (zero_2 == 0)
{
    FSkip(1);
        zero_2 = ReadByte();
} // Some models have 2 bytes empty before the vertex buffer

    Vertices vertices[VertexCount] <name="Vertices", optimize=false>;
} TRM <name="Tomb Raider I-V Remastered .TRM Model", comment="Tomb Raider I-V Remastered .TRM File">;